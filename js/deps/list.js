// Generated by CoffeeScript 1.12.4
var exec, fs, linkDep, lowercased, npmRoot, path, readDeps, resolveModule, sync;

resolveModule = require("resolve").resolveModule;

exec = require("exec");

path = require("path");

sync = require("sync");

fs = require("io/sync");

module.exports = function(args) {
  var deps, entryPath, manifest;
  entryPath = args._.length ? path.resolve(args._[0]) : process.cwd();
  deps = readDeps(entryPath, {
    depth: args.depth || 2e308
  });
  log.moat(1);
  log.white("Found " + (Object.keys(deps).length) + " dependencies!");
  log.moat(1);
  sync.each(deps, function(moduleJson, moduleName) {
    moduleJson.versions = Array.from(moduleJson.versions);
    moduleJson.dependers = Array.from(moduleJson.dependers);
  });
  manifest = JSON.stringify(deps, null, 2);
  fs.write(entryPath + "/manifest.json", manifest);
};

npmRoot = exec.sync("npm root -g");

lowercased = Object.create(null);

readDeps = function(modulePath, options) {
  var collision, depth, globalPath, json, jsonPath, moduleHash, moduleName;
  if (options == null) {
    options = {};
  }
  if (options.deps == null) {
    options.deps = Object.create(null);
  }
  if (!path.isAbsolute(modulePath)) {
    throw Error("'modulePath' must be absolute:\n  " + modulePath);
  }
  moduleName = path.basename(modulePath);
  moduleHash = moduleName.toLowerCase();
  if (collision = lowercased[moduleHash]) {
    if (moduleName !== collision.dep) {
      log.warn("Possibly incorrect capitalization:\n  " + options.parent + " -> " + moduleName + "\n\nThis module is also required with a similar name:\n  " + collision.parent + " -> " + collision.dep);
      return;
    }
    lowercased[moduleHash] = {
      parent: options.parent,
      dep: moduleName
    };
  }
  jsonPath = path.join(modulePath, "package.json");
  if (!fs.isFile(jsonPath)) {
    log.warn("Package does not exist:\n  " + jsonPath);
    return options.deps;
  }
  if (0 > modulePath.indexOf("/node_modules/")) {
    globalPath = path.join(npmRoot, moduleName);
    linkDep(globalPath, modulePath);
  }
  json = require(jsonPath);
  if (!(json && json.dependencies)) {
    return options.deps;
  }
  if (options._depth == null) {
    options._depth = 0;
  }
  depth = options._depth += 1;
  sync.each(json.dependencies, function(version, depName) {
    var dep, depPath, gray, red, ref;
    ref = log.color, red = ref.red, gray = ref.gray;
    if (version.indexOf(path.sep) >= 0) {
      depPath = resolveModule(depName, modulePath);
      if (!depPath) {
        log.warn("Failed to resolve dependency:\n  " + modulePath + "\n  -> " + (red(depName)));
        return;
      }
      if (dep = options.deps[depPath]) {
        dep.versions.add(version);
        dep.dependers.add(modulePath);
        return;
      }
      log.it(gray(depPath));
      options.deps[depPath] = {
        versions: new Set([version]),
        dependers: new Set([modulePath])
      };
      if (depth < options.depth) {
        options.parent = modulePath;
        readDeps(depPath, options);
        options._depth = depth;
      }
      return;
    }
    if (dep = options.deps[depName]) {
      dep.versions.add(version);
      dep.dependers.add(modulePath);
      return;
    }
    log.it(gray(depName));
    options.deps[depName] = {
      versions: new Set([version]),
      dependers: new Set([modulePath])
    };
  });
  options._depth -= 1;
  return options.deps;
};

linkDep = function(linkPath, modulePath) {
  var green;
  if (fs.isLink(linkPath) && !fs.isLinkBroken(linkPath)) {
    return;
  }
  green = log.color.green;
  log.moat(1);
  log("Linking:\n  " + (green(linkPath)) + "\n  -> " + modulePath);
  log.moat(1);
  return fs.writeLink(linkPath, modulePath);
};
