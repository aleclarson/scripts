// Generated by CoffeeScript 1.12.4
var bumpDependency, exec, fs, getLatestVersion, git, missingVersions, npmRoot, parseUsername, parseVersion, path, prompt, readVersions, semver, sortObject, updateCurrentPackage, updateDependingPackage, updateDependingPackages, updatePackageJson;

sortObject = require("sortObject");

semver = require("node-semver");

prompt = require("prompt");

path = require("path");

exec = require("exec");

git = require("git-utils");

fs = require("io/sync");

npmRoot = exec.sync("npm root -g");

module.exports = function(depNames, args) {
  if (!depNames.length) {
    return log.warn("Must specify at least one dependency name!");
  }
  if (args.v != null) {
    if (depNames.length > 1) {
      return log.warn("Cannot specify -v when updating multiple dependencies!");
    }
    if (!(semver.valid(args.v) || semver.validRange(args.v))) {
      return log.warn("Malformed version: '" + args.v + "'");
    }
  }
  if (args.scan) {
    return updateDependingPackages(depNames, args);
  } else {
    return updateCurrentPackage(depNames, args);
  }
};

updateCurrentPackage = function(depNames, args) {
  var jsonPath, latestVersions;
  jsonPath = path.resolve("package.json");
  if (!fs.isFile(jsonPath)) {
    log.warn("Missing json: '" + jsonPath + "'");
    return;
  }
  latestVersions = readVersions(depNames, args);
  return updatePackageJson(jsonPath, function(json) {
    var depName, latestVersion, parent;
    parent = {
      json: json,
      path: path.dirname(jsonPath)
    };
    for (depName in latestVersions) {
      latestVersion = latestVersions[depName];
      if (latestVersion) {
        bumpDependency(depName, latestVersion, args, parent);
      } else {
        log.warn("Missing version: '" + depName + "'");
      }
    }
  });
};

updateDependingPackages = function(depNames, args) {
  var cancelled, i, latestVersions, len, moduleName, moduleNames;
  latestVersions = readVersions(depNames, args);
  moduleNames = fs.readDir(".");
  for (i = 0, len = moduleNames.length; i < len; i++) {
    moduleName = moduleNames[i];
    cancelled = updateDependingPackage(moduleName, latestVersions, args);
    if (cancelled) {
      return;
    }
  }
};

missingVersions = {};

updateDependingPackage = function(moduleName, latestVersions, args) {
  var jsonPath, modulePath;
  modulePath = path.resolve(moduleName);
  jsonPath = path.join(modulePath, "package.json");
  if (!fs.isFile(jsonPath)) {
    return false;
  }
  return updatePackageJson(jsonPath, function(json) {
    var depName, deps, devDeps, diff, latestVersion, oldValue, oldVersion, parent, shouldBump;
    deps = json.dependencies;
    devDeps = json.devDependencies;
    if (!(deps || devDeps)) {
      return false;
    }
    parent = {
      json: json,
      path: modulePath
    };
    for (depName in latestVersions) {
      latestVersion = latestVersions[depName];
      if (deps != null) {
        oldValue = deps[depName];
      }
      if ((devDeps != null) && !oldValue) {
        oldValue = devDeps[depName];
      }
      if (!oldValue) {
        continue;
      }
      if (!latestVersion) {
        if (!missingVersions[depName]) {
          missingVersions[depName] = true;
          log.warn("Missing version: '" + depName + "'");
        }
        continue;
      }
      oldVersion = parseVersion(oldValue);
      if (semver.gte(oldVersion, latestVersion)) {
        continue;
      }
      diff = semver.diff(oldVersion, latestVersion);
      if ((args.only != null) && diff !== args.only) {
        continue;
      }
      log.moat(1);
      log.yellow(moduleName);
      log.moat(0);
      log.plusIndent(2);
      log.gray("current: ");
      log.white(oldVersion);
      log.moat(0);
      if (diff === "patch") {
        log.gray("auto-bumping: ");
        log.green(latestVersion);
        log.moat(1);
        shouldBump = true;
      } else {
        log.gray("latest:  ");
        log.green(latestVersion);
        log.moat(1);
        shouldBump = prompt.sync({
          bool: true
        });
      }
      log.popIndent();
      if (shouldBump === null) {
        return true;
      }
      if (shouldBump) {
        bumpDependency(depName, latestVersion, args, parent);
      }
    }
    return false;
  });
};

getLatestVersion = function(moduleName, isRemote) {
  var json, jsonPath, moduleParent, modulePath;
  if (isRemote) {
    return exec.sync("npm view " + moduleName + " version");
  }
  moduleParent = process.cwd();
  while (moduleParent !== path.sep) {
    modulePath = path.join(moduleParent, "node_modules", moduleName);
    if (fs.isDir(modulePath)) {
      break;
    }
    moduleParent = path.dirname(moduleParent);
  }
  if (modulePath == null) {
    modulePath = path.join(npmRoot, moduleName);
  }
  jsonPath = path.join(modulePath, "package.json");
  if (!fs.isFile(jsonPath)) {
    return;
  }
  json = JSON.parse(fs.read(jsonPath));
  return json.version;
};

readVersions = function(depNames, args) {
  var depName, i, len, versions;
  versions = {};
  if (args.v != null) {
    versions[depNames[0]] = args.v;
    return versions;
  }
  for (i = 0, len = depNames.length; i < len; i++) {
    depName = depNames[i];
    versions[depName] = getLatestVersion(depName, args.remote);
  }
  return versions;
};

updatePackageJson = function(jsonPath, updater) {
  var json, result;
  json = JSON.parse(fs.read(jsonPath));
  result = updater(json);
  json = JSON.stringify(json, null, 2);
  fs.write(jsonPath, json + log.ln);
  return result;
};

parseVersion = function(string) {
  if (0 <= string.indexOf("#")) {
    return string.split("#")[1];
  }
  return string;
};

parseUsername = function(string) {
  var parts;
  parts = string.split("/");
  if (0 <= string.indexOf("://")) {
    parts = parts.splice(-2);
  }
  if (parts.length > 1) {
    return parts.shift();
  }
  return null;
};

bumpDependency = function(depName, newVersion, args, parent) {
  var depPath, deps, depsKey, error, green, newValue, oldValue, ref, targetPath, username, yellow;
  depsKey = args.dev ? "devDependencies" : "dependencies";
  deps = parent.json[depsKey] || {};
  oldValue = deps[depName];
  if (!args.remote) {
    username = args.ours ? exec.sync("git config --get user.name") : oldValue ? parseUsername(oldValue) : null;
  }
  newValue = username ? username + "/" + depName + "#" + newVersion : newVersion;
  if (newValue === oldValue) {
    log.warn(depName + " v" + newVersion + " is already installed!");
    return;
  }
  deps[depName] = newValue;
  parent.json[depsKey] = sortObject(deps);
  if (!args.scan) {
    log.moat(1);
    log.white(depName);
    log.moat(0);
    if (oldValue) {
      log.gray(parseVersion(oldValue));
      log.white(" -> ");
    }
    log.green(newVersion);
    log.moat(1);
  }
  depPath = path.resolve(parent.path, "node_modules", depName);
  if (fs.exists(depPath)) {
    return;
  }
  ref = log.color, green = ref.green, yellow = ref.yellow;
  if (args.ours) {
    targetPath = path.resolve(npmRoot, depName);
    log.moat(1);
    log.white("Creating symlink..\n  " + (green(depPath)) + "\n..that points to:\n  " + (yellow(targetPath)));
    log.moat(1);
    log.flush();
    fs.writeDir(path.dirname(depPath));
    fs.writeLink(depPath, targetPath);
    return;
  }
  log.moat(1);
  log.white("Installing:\n  " + (green(depPath)));
  log.moat(1);
  log.flush();
  try {
    exec.sync("npm install " + depPath, {
      cwd: parent.path
    });
  } catch (error1) {
    error = error1;
    if (!/WARN/.test(error.message)) {
      throw error;
    }
  }
};
