// Generated by CoffeeScript 1.12.4
var AsyncTaskGroup, OneOf, config, exec, getInverseDependencies, git, ignored, readModules, sortModules;

AsyncTaskGroup = require("AsyncTaskGroup");

OneOf = require("OneOf");

exec = require("exec");

git = require("git-utils");

getInverseDependencies = require("../utils/getInverseDependencies");

sortModules = require("../utils/sortModules");

readModules = require("../utils/readModules");

config = require("../../config.json");

ignored = OneOf(config.ignore);

module.exports = function(args) {
  var mods, outdated, tasks;
  outdated = Object.create(null);
  log.moat(1);
  log.gray("Finding modules with outdated master branches...");
  log.moat(1);
  log.flush();
  mods = readModules(process.cwd(), function(file, json) {
    return git.isRepo(file) && !ignored.test(json.name);
  });
  tasks = AsyncTaskGroup({
    maxConcurrent: 20
  });
  return tasks.map(Object.keys(mods), function(name) {
    var file, json, ref;
    ref = mods[name], file = ref.file, json = ref.json;
    return Promise.all([git.isClean(file), git.hasBranch(file, "unstable")]).then(function(arg) {
      var hasBranch, isClean;
      isClean = arg[0], hasBranch = arg[1];
      if (!(isClean && hasBranch)) {
        return;
      }
      return exec.async("git diff --name-status master unstable", {
        cwd: file
      }).then(function(stdout) {
        if (stdout.length === 0) {
          return;
        }
        return outdated[name] = {
          file: file,
          json: json
        };
      });
    });
  }).then(function() {
    var sorted, sortedKeys;
    log.moat(1);
    log.gray("Sorting modules...");
    log.moat(1);
    log.flush();
    sortedKeys = Object.create(null);
    sorted = sortModules(outdated, function(arg) {
      var _, dep, json, ref;
      json = arg.json;
      ref = json.dependencies;
      for (dep in ref) {
        _ = ref[dep];
        if (!outdated[dep]) {
          continue;
        }
        if (!sortedKeys[dep]) {
          return false;
        }
      }
      sortedKeys[json.name] = true;
      return true;
    });
    sorted.forEach(function(arg) {
      var _, dep, json, ref;
      json = arg.json;
      log.moat(1);
      log.white(json.name);
      log.plusIndent(2);
      ref = json.dependencies;
      for (dep in ref) {
        _ = ref[dep];
        if (!outdated[dep]) {
          continue;
        }
        log.moat(0);
        log.gray(dep);
      }
      log.popIndent();
      log.moat(1);
      return log.flush();
    });
  });
};
