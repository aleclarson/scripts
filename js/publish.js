// Generated by CoffeeScript 1.12.4
var AsyncTaskGroup, Promise, createDistBranch, ensureMasterBranch, exec, fs, git, hasKeys, ignoredPaths, log, path, squashDistBranch, updateDistBranch, updateGitignore, updatePackageJson, updateTag;

require("LazyVar");

AsyncTaskGroup = require("AsyncTaskGroup");

Promise = require("Promise");

hasKeys = require("hasKeys");

path = require("path");

exec = require("exec");

git = require("git-utils");

log = require("log");

fs = require("io/sync");

updateTag = require("./tag");

module.exports = function(args) {
  var moduleName, modulePath, promise;
  modulePath = path.resolve(args._[0] || "");
  moduleName = path.basename(modulePath);
  process.chdir(modulePath.slice(0, modulePath.length - moduleName.length));
  promise = updateTag({
    _: [moduleName]
  });
  return promise != null ? promise.then(function() {
    return updateDistBranch(modulePath);
  }) : void 0;
};

ensureMasterBranch = function(modulePath, options) {
  if (options == null) {
    options = {};
  }
  return git.isClean(modulePath).then(function(isClean) {
    var promise;
    if (isClean) {
      return promise = Promise.resolve();
    } else if (options.forceClean) {
      return promise = git.resetBranch(modulePath, "HEAD", {
        clean: true
      });
    } else {
      throw Error("is not clean");
    }
  }).then(function() {
    return git.getBranch(modulePath).then(function(branch) {
      if (branch !== "master") {
        return git.setBranch(modulePath, "master");
      }
    });
  });
};

createDistBranch = function(modulePath) {
  var branch;
  branch = "dist";
  return git.hasBranch(modulePath, branch).then(function(hasBranch) {
    if (hasBranch) {
      return git.deleteBranch(modulePath, branch);
    }
  }).then(function() {
    return git.addBranch(modulePath, branch);
  });
};

ignoredPaths = ["src/", "spec/", "**/*.map", "README.md", "LICENSE"];

updateGitignore = function(modulePath) {
  var filePath, ignored, index;
  filePath = modulePath + "/.gitignore";
  ignored = fs.read(filePath).split("\n");
  if (-1 !== (index = ignored.indexOf("js/"))) {
    ignored.splice(index, 1);
  }
  ignoredPaths.forEach(function(ignoredPath) {
    if (-1 === ignored.indexOf(ignoredPath)) {
      return ignored.push(ignoredPath);
    }
  });
  return fs.write(filePath, ignored.join("\n"));
};

updatePackageJson = function(jsonPath) {
  var buildScript, pjson;
  pjson = require(jsonPath);
  delete pjson.plugins;
  delete pjson.devDependencies;
  delete pjson.implicitDependencies;
  if (pjson.scripts) {
    delete pjson.scripts.postinstall;
    if (buildScript = pjson.scripts.build) {
      if (buildScript.startsWith("coffee-build ")) {
        exec.sync("coffee -cb -o js src", {
          cwd: path.dirname(jsonPath)
        });
      }
      delete pjson.scripts.build;
    }
    if (!hasKeys(pjson.scripts)) {
      delete pjson.scripts;
    }
  }
  pjson = JSON.stringify(pjson, null, 2);
  return fs.write(jsonPath, pjson + "\n");
};

squashDistBranch = function(modulePath) {
  return git.getBranch(modulePath).then(function(branch) {
    if (branch !== "dist") {
      throw Error("must be on 'dist' branch");
    }
    return git.findVersion(modulePath, "*").then(function(version) {
      if (version === null) {
        throw Error("has no version tag");
      }
      return git.resetBranch(modulePath, null).then(function() {
        return git.stageFiles(modulePath, "*");
      }).then(function() {
        return exec.async("git rm -r --cached .", {
          cwd: modulePath
        });
      }).then(function() {
        return git.stageFiles(modulePath, "*");
      }).then(function() {
        log.moat(1);
        log.white("Publishing:");
        log.moat(0);
        log.plusIndent(2);
        log.gray("module:  ");
        log.green(path.basename(modulePath));
        log.moat(0);
        log.gray("version: ");
        log.green(version);
        log.popIndent();
        log.moat(1);
        return git.pushVersion(modulePath, version, {
          force: true
        });
      });
    });
  });
};

updateDistBranch = function(modulePath) {
  var jsonPath, moduleName;
  moduleName = path.basename(modulePath);
  if (!fs.isDir(modulePath)) {
    throw Error("'" + moduleName + "' is not a directory!");
  }
  jsonPath = path.join(modulePath, "package.json");
  if (!fs.isFile(jsonPath)) {
    throw Error("'" + moduleName + "' has no package.json file!");
  }
  return Promise.all([git.isClean(modulePath), git.getBranch(modulePath)]).then(function(isClean, branch) {
    if (isClean || (branch === null)) {
      return;
    }
    throw Error("is not clean");
  }).then(function() {
    return ensureMasterBranch(modulePath).then(function() {
      return createDistBranch(modulePath);
    }).then(function() {
      return updateGitignore(modulePath);
    }).then(function() {
      return updatePackageJson(jsonPath);
    }).then(function() {
      return squashDistBranch(modulePath);
    }).then(function() {
      return ensureMasterBranch(modulePath, {
        forceClean: true
      });
    });
  }).then(function() {
    return git.setBranch(modulePath, "unstable");
  }).fail(function(error) {
    log.moat(1);
    log.white(path.basename(modulePath));
    log.red(" " + error.message + "!");
    log.moat(0);
    log.gray(error.stack);
    return log.moat(1);
  }).then(function() {
    return exec.async("coffee -cb -o js src", {
      cwd: modulePath
    });
  });
};
