// Generated by CoffeeScript 1.12.4
var AsyncTaskGroup, OneOf, config, getInverseDependencies, git, ignored, readModules, sortModules;

AsyncTaskGroup = require("AsyncTaskGroup");

OneOf = require("OneOf");

git = require("git-utils");

getInverseDependencies = require("../utils/getInverseDependencies");

sortModules = require("../utils/sortModules");

readModules = require("../utils/readModules");

config = require("../../config.json");

ignored = OneOf(config.ignore);

module.exports = function(args) {
  var dirty, mods, tasks;
  dirty = Object.create(null);
  log.moat(1);
  log.gray("Finding modules with uncommitted changes...");
  log.moat(1);
  log.flush();
  mods = readModules(process.cwd(), function(file, json) {
    return git.isRepo(file) && !ignored.test(json.name);
  });
  tasks = AsyncTaskGroup({
    maxConcurrent: 20
  });
  return tasks.map(Object.keys(mods), function(name) {
    var file, json, ref;
    ref = mods[name], file = ref.file, json = ref.json;
    return git.isClean(file).then(function(isClean) {
      return isClean || (dirty[name] = {
        file: file,
        json: json
      });
    });
  }).then(function() {
    var sorted, sortedKeys;
    log.moat(1);
    log.gray("Sorting modules...");
    log.moat(1);
    log.flush();
    sortedKeys = Object.create(null);
    sorted = sortModules(dirty, function(arg) {
      var _, dep, json, ref;
      json = arg.json;
      ref = json.dependencies;
      for (dep in ref) {
        _ = ref[dep];
        if (!dirty[dep]) {
          continue;
        }
        if (!sortedKeys[dep]) {
          return false;
        }
      }
      sortedKeys[json.name] = true;
      return true;
    });
    sorted.forEach(function(arg) {
      var _, dep, json, ref;
      json = arg.json;
      log.moat(1);
      log.white(json.name);
      log.plusIndent(2);
      ref = json.dependencies;
      for (dep in ref) {
        _ = ref[dep];
        if (!dirty[dep]) {
          continue;
        }
        log.moat(0);
        log.gray(dep);
      }
      log.popIndent();
      log.moat(1);
      return log.flush();
    });
  });
};
